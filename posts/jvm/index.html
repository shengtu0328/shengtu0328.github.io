<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>JVM学习 - ricky的网站</title><meta name="Description" content="The best time to plant a tree was 10 years ago, the second is now"><meta property="og:title" content="JVM学习" />
<meta property="og:description" content="一、什么是JVM 定义 Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境） 功能 解释和运行 对字节码文件中的指令，实时的解" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://shengtu0328.github.io/posts/jvm/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-11T18:23:30+08:00" />
<meta property="article:modified_time" content="2022-10-11T18:23:30+08:00" /><meta property="og:site_name" content="我的网站" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JVM学习"/>
<meta name="twitter:description" content="一、什么是JVM 定义 Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境） 功能 解释和运行 对字节码文件中的指令，实时的解"/>
<meta name="application-name" content="我的网站">
<meta name="apple-mobile-web-app-title" content="我的网站"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://shengtu0328.github.io/posts/jvm/" /><link rel="prev" href="https://shengtu0328.github.io/posts/ffmpeg/" /><link rel="next" href="https://shengtu0328.github.io/posts/spring/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "JVM学习",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/shengtu0328.github.io\/posts\/jvm\/"
        },"genre": "posts","wordcount":  13639 ,
        "url": "https:\/\/shengtu0328.github.io\/posts\/jvm\/","datePublished": "2022-10-11T18:23:30+08:00","dateModified": "2022-10-11T18:23:30+08:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "ricky"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('dark' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'dark' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="ricky的网站">Ricky’s blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="ricky的网站">Ricky’s blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">JVM学习</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>ricky</a>
</span>&nbsp;<span class="post-category">included in <a href="/categories/tech/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>tech</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2022-10-11">2022-10-11</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;13639 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;28 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#一什么是jvm">一、什么是JVM</a>
      <ul>
        <li><a href="#定义">定义</a></li>
        <li><a href="#功能">功能</a></li>
        <li><a href="#好处">好处</a></li>
        <li><a href="#jvm参数">jvm参数</a></li>
      </ul>
    </li>
    <li><a href="#二内存结构">二、内存结构</a>
      <ul>
        <li><a href="#1程序计数器">1、程序计数器</a>
          <ul>
            <li><a href="#作用">作用</a></li>
            <li><a href="#特点">特点</a></li>
          </ul>
        </li>
        <li><a href="#2虚拟机栈">2、虚拟机栈</a>
          <ul>
            <li><a href="#定义-1">定义</a></li>
            <li><a href="#演示">演示</a></li>
            <li><a href="#问题辨析">问题辨析</a></li>
            <li><a href="#内存溢出">内存溢出</a></li>
            <li><a href="#线程运行诊断">线程运行诊断</a></li>
          </ul>
        </li>
        <li><a href="#3本地方法栈">3、本地方法栈</a></li>
        <li><a href="#4堆">4、堆</a>
          <ul>
            <li><a href="#定义-2">定义</a></li>
            <li><a href="#特点-1">特点</a></li>
            <li><a href="#堆内存溢出">堆内存溢出</a></li>
            <li><a href="#堆内存诊断">堆内存诊断</a></li>
          </ul>
        </li>
        <li><a href="#5方法区">5、方法区</a>
          <ul>
            <li><a href="#定义-3">定义</a></li>
            <li><a href="#内存溢出-1">内存溢出</a></li>
            <li><a href="#常量池">常量池</a>
              <ul>
                <li><a href="#定义-4">定义</a></li>
                <li><a href="#举例说明">举例说明</a></li>
              </ul>
            </li>
            <li><a href="#stringtable串池">StringTable（串池）</a>
              <ul>
                <li><a href="#举例说明依据字节码">举例说明(依据字节码)</a></li>
                <li><a href="#特征">特征</a></li>
                <li><a href="#intern方法-18">intern方法 1.8</a></li>
                <li><a href="#intern方法-16">intern方法 1.6</a></li>
                <li><a href="#垃圾回收">垃圾回收</a></li>
                <li><a href="#stringtable调优">StringTable调优</a></li>
              </ul>
            </li>
            <li><a href="#直接内存">直接内存</a>
              <ul>
                <li><a href="#释放原理">释放原理</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#三垃圾回收">三、垃圾回收</a>
      <ul>
        <li><a href="#1如何判断对象可以回收">1、如何判断对象可以回收</a>
          <ul>
            <li><a href="#引用计数法">引用计数法</a></li>
            <li><a href="#可达性分析算法jvm使用的">可达性分析算法（JVM使用的）</a></li>
            <li><a href="#可以作为gc-root的对象">可以作为GC Root的对象</a></li>
            <li><a href="#五种引用">五种引用</a>
              <ul>
                <li><a href="#引用队列的作用">引用队列的作用</a></li>
                <li><a href="#软引用或者弱引是怎么被回收的">软引用或者弱引是怎么被回收的</a></li>
                <li><a href="#强引用">强引用</a></li>
                <li><a href="#软引用">软引用</a></li>
                <li><a href="#弱引用">弱引用</a></li>
                <li><a href="#虚引用cleaner-类和-reference-handler"><strong>虚引用</strong>（Cleaner 类和 reference handler）</a></li>
                <li><a href="#终结器引用">终结器引用</a></li>
                <li><a href="#引用队列">引用队列</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#2垃圾回收算法">2、垃圾回收算法</a>
          <ul>
            <li><a href="#标记-清除">标记-清除</a></li>
            <li><a href="#标记-整理">标记-整理</a></li>
            <li><a href="#复制">复制</a></li>
            <li><a href="#总结">总结</a></li>
          </ul>
        </li>
        <li><a href="#3分代回收就是指堆内存">3、分代回收(就是指堆内存)</a></li>
        <li><a href="#4jvm参数">4、JVM参数</a>
          <ul>
            <li><a href="#gc-分析">GC 分析</a>
              <ul>
                <li><a href="#大对象处理策略">大对象处理策略</a></li>
                <li><a href="#线程内存溢出">线程内存溢出</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#4垃圾回收器">4、垃圾回收器</a>
          <ul>
            <li><a href="#串行的-单线程的垃圾回收器">串行的 (单线程的垃圾回收器)</a></li>
            <li><a href="#吞吐量优先多线程的垃圾回收器">吞吐量优先(多线程的垃圾回收器)</a></li>
            <li><a href="#响应时间优先多线程的垃圾回收器如cms">响应时间优先(多线程的垃圾回收器，如CMS)</a>
              <ul>
                <li><a href="#cms-收集器">CMS 收集器</a></li>
              </ul>
            </li>
            <li><a href="#g1">G1</a>
              <ul>
                <li><a href="#定义-5"><strong>定义</strong>：</a></li>
                <li><a href="#适用场景">适用场景</a></li>
                <li><a href="#1young-collection">1.Young Collection</a></li>
                <li><a href="#2young-collection--cm">2.Young Collection + CM</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#5直接内存">5、直接内存</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="一什么是jvm">一、什么是JVM</h2>
<h3 id="定义">定义</h3>
<p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p>
<h3 id="功能">功能</h3>
<p><strong>解释和运行</strong>  对字节码文件中的指令，实时的解释成机器码，让计算机执行</p>
<p><strong>内存管理</strong>    自动为对象、方法等分配内存，自动的垃圾回收机制</p>
<p><strong>即时编译</strong>   对热点代码进行优化，提升执行效率 ( java 语言需要将字节码指令实时地通过jvm解释成机器码，才可以交给计算机运行，随着程序的执行，需要反复地去进行，</p>
<p>每次运行都要经历  解释成机器码&mdash;&ndash;&gt;运行机器码 这两部</p>
<p>但有了jit后  直接把热点代码的机器码放进内存中， 少了解释成机器码文件这一步   )</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="jit.png"
        data-srcset="jit.png, jit.png 1.5x, jit.png 2x"
        data-sizes="auto"
        alt="jit.png"
        title="jit.png" /></p>
<h3 id="好处">好处</h3>
<ul>
<li>
<p>一次编写，到处运行 (屏蔽了字节码和操作系统和的差异，对外提供一致的操作环境，从而可以跨平台，如在windows，linux运行、)</p>
</li>
<li>
<p>自动内存管理，垃圾回收机制 (c,c++之前没有自动垃圾回收)</p>
</li>
<li>
<p>数组下标越界检查 （c语言也没有?）</p>
</li>
<li>
<p>多态（虚方法表实现？)</p>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="001.png"
        data-srcset="001.png, 001.png 1.5x, 001.png 2x"
        data-sizes="auto"
        alt="001.png"
        title="001.png" /></p>
<h3 id="jvm参数">jvm参数</h3>
<ul>
<li>
<p>栈内存大小</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-Xss1024k
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>堆内存大小</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-Xmx4G
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>永久代大小 1.8 以前</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-XX:MaxPermSize=8m
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>元空间大小 1.8 以后</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-XX:MaxMetaspaceSize=8m
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>堆空间回收不足开关 +是启用，-是不启用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-XX:-UseGCOverheadLimit
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">+XX:-UseGCOverheadLimit
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>StringTable 桶个数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-XX:StringTableSize=20000
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>禁用显示垃圾回收，如System.gc() 注意：System.gc()是full gc，新生代，老年代。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-XX:+DisableExplicitGC 显式的
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="二内存结构">二、内存结构</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="002.png"
        data-srcset="002.png, 002.png 1.5x, 002.png 2x"
        data-sizes="auto"
        alt="002.png"
        title="002.png" /></p>
<ul>
<li>
<p>方法区:存放了类</p>
</li>
<li>
<p>堆:存放了对象</p>
</li>
<li>
<p>虚拟机栈&amp;程序器计数器&amp;本地方法栈: 对象调用方法时会用到</p>
</li>
<li>
<p>解释器:每行代码执行</p>
</li>
<li>
<p>即时的编译器:热点代码执行</p>
</li>
<li>
<p>垃圾回收:回收在堆中不被引用的对象</p>
</li>
<li>
<p>本地方法接口:操作系统的功能方法</p>
</li>
</ul>
<h3 id="1程序计数器">1、程序计数器</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="005.png"
        data-srcset="005.png, 005.png 1.5x, 005.png 2x"
        data-sizes="auto"
        alt="005.png"
        title="005.png" /></p>
<h4 id="作用">作用</h4>
<p>用于保存JVM中下一条所要执行的指令的地址</p>
<h4 id="特点">特点</h4>
<ul>
<li>
<p>线程私有</p>
<ul>
<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li>
<li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，每个线程都有自己的程序计数器，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li>
</ul>
</li>
<li>
<p>不会存在内存溢出.</p>
</li>
</ul>
<h3 id="2虚拟机栈">2、虚拟机栈</h3>
<h4 id="定义-1">定义</h4>
<ul>
<li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li>
<li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用<strong>方法</strong>时所占用的内存</li>
<li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li>
<li>Student s=new Student()；s这个变量也是在栈里，new Student()对象是在堆里</li>
</ul>
<h4 id="演示">演示</h4>
<p>代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class Main {
</span></span><span class="line"><span class="cl">	public static void main(String[] args) {
</span></span><span class="line"><span class="cl">		method1();
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	private static void method1() {
</span></span><span class="line"><span class="cl">		method2(1, 2);
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	private static int method2(int a, int b) {
</span></span><span class="line"><span class="cl">		int c = a + b;
</span></span><span class="line"><span class="cl">		return c;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以参考idea debug模式下的 Frames</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="008_stack.png"
        data-srcset="008_stack.png, 008_stack.png 1.5x, 008_stack.png 2x"
        data-sizes="auto"
        alt="008_stack.png"
        title="008_stack.png" /></p>
<h4 id="问题辨析">问题辨析</h4>
<ul>
<li>
<p>垃圾回收是否涉及栈内存？</p>
<ul>
<li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>
</ul>
</li>
<li>
<p>栈内存的分配越大越好吗？</p>
<ul>
<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li>
<li>线程数=物理内存/栈内存</li>
<li>-Xss1024k （栈内存JVM默认参数配置，默认大小是1M）</li>
</ul>
</li>
<li>
<p>方法内的局部变量是否是线程安全的？</p>
<ul>
<li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li>
<li>如果如果<strong>局部变量引用了对象</strong>或者静态变量，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li>
</ul>
</li>
</ul>
<h4 id="内存溢出">内存溢出</h4>
<p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p>
<p><strong>发生原因</strong></p>
<ul>
<li>
<p>虚拟机栈中，<strong>栈帧过多</strong>（无限递归，第三方库出现的问题如json序列化对象互相引用）</p>
</li>
<li>
<p>每个栈帧<strong>所占用过大</strong></p>
<p>可以通过idea中Configurations中设置VM options 设置jvm参数：如-Xss256k</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="012.png"
        data-srcset="012.png, 012.png 1.5x, 012.png 2x"
        data-sizes="auto"
        alt="012.png"
        title="012.png" /></p>
</li>
</ul>
<h4 id="线程运行诊断">线程运行诊断</h4>
<p>CPU占用过高</p>
<ul>
<li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程
<ul>
<li>
<p><strong>top</strong></p>
<p>查看<strong>进程</strong>的CPU和内存使用情况,会显示进程id(PID),但还定位不到线程，</p>
</li>
<li>
<p><strong>ps H -eo pid,tid,%cpu | grep 我是刚才通过top查到的进程号</strong></p>
<p>查看<strong>线程</strong>占用CPU和内存使用情况</p>
<p><strong>H</strong> 是显示进程里所有线程树的意思</p>
<p><strong>-eo</strong>是输出结果 ，**pid:**进程id，<strong>tid:<strong>线程id，,</strong>%cpu</strong>:cpu占用率</p>
</li>
<li>
<p><strong>jstack 我是一个进程id</strong></p>
<p>通过查看进程中的线程的id，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="3本地方法栈">3、本地方法栈</h3>
<p>​    <img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="016_nativeMethod.png"
        data-srcset="016_nativeMethod.png, 016_nativeMethod.png 1.5x, 016_nativeMethod.png 2x"
        data-sizes="auto"
        alt="016_nativeMethod.png"
        title="016_nativeMethod.png" /></p>
<p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p>
<h3 id="4堆">4、堆</h3>
<p>Heap 堆</p>
<p>​    <img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="017_%e5%a0%86.png"
        data-srcset="017_%e5%a0%86.png, 017_%e5%a0%86.png 1.5x, 017_%e5%a0%86.png 2x"
        data-sizes="auto"
        alt="017_堆.png"
        title="017_堆.png" /></p>
<h4 id="定义-2">定义</h4>
<p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p>
<h4 id="特点-1">特点</h4>
<ul>
<li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li>
<li>有垃圾回收机制</li>
<li>jvm参数：-Xmx4G   可以通过修改jvm堆内存的参数大小，尽早暴露问题</li>
</ul>
<h4 id="堆内存溢出">堆内存溢出</h4>
<p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p>
<p>比如一个size很大的list，就会发生堆内存溢出</p>
<h4 id="堆内存诊断">堆内存诊断</h4>
<ol>
<li>jps 工具</li>
</ol>
<ul>
<li>
<p>查看当前系统中有哪些 java 进程</p>
</li>
<li>
<p>jps</p>
</li>
</ul>
<ol start="2">
<li>jmap 工具</li>
</ol>
<ul>
<li>
<p>查看堆内存占用情况 jmap - heap 进程id，只能是某一时刻</p>
</li>
<li>
<p>jmap -heap 5750</p>
</li>
</ul>
<ol start="3">
<li>jconsole 工具</li>
</ol>
<ul>
<li>
<p>图形界面的，多功能的监测工具，可以连续监测</p>
</li>
<li>
<p>jconsole</p>
<p>​    <img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="020_jconsole.png"
        data-srcset="020_jconsole.png, 020_jconsole.png 1.5x, 020_jconsole.png 2x"
        data-sizes="auto"
        alt="020_jconsole.png"
        title="020_jconsole.png" /></p>
</li>
</ul>
<ol start="4">
<li>java VisualVm</li>
</ol>
<ul>
<li>
<p>jvisualvm 图形界面，更加强大，类似idea debug模式下看到的信息</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="021_jvisualvm.png"
        data-srcset="021_jvisualvm.png, 021_jvisualvm.png 1.5x, 021_jvisualvm.png 2x"
        data-sizes="auto"
        alt="021_jvisualvm.png"
        title="021_jvisualvm.png" /></p>
</li>
</ul>
<h3 id="5方法区">5、方法区</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="022_%e6%96%b9%e6%b3%95%e5%8c%ba.png"
        data-srcset="022_%e6%96%b9%e6%b3%95%e5%8c%ba.png, 022_%e6%96%b9%e6%b3%95%e5%8c%ba.png 1.5x, 022_%e6%96%b9%e6%b3%95%e5%8c%ba.png 2x"
        data-sizes="auto"
        alt="022_方法区.png"
        title="022_方法区.png" /></p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4" target="_blank" rel="noopener noreffer">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4</a>
</p>
<p>The Java Virtual Machine has a <em><strong>method area</strong></em> that is <strong>shared among all Java Virtual Machine threads</strong>. The method area is analogous（相似的） to the storage area for compiled code of a conventional language or analogous to the &ldquo;text&rdquo; segment in an operating system process. It stores per-class structures such as the run-time constant pool（<strong>运行时常量池</strong>), field （ ）and method data, and the code for methods(<strong>方法</strong>) and constructors（<strong>构造方法</strong>）, including the special methods (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9" target="_blank" rel="noopener noreffer">§2.9</a>
) used in class and instance initialization and interface initialization.</p>
<p>The method area is created on virtual machine start-up. Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it. This specification does not mandate the location of the method area or the policies used to manage compiled code. The method area may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger method area becomes unnecessary. The memory for the method area does not need to be contiguous.</p>
<h4 id="定义-3">定义</h4>
<ul>
<li>
<p>方法区是所有线程共享的，存储了运行时常量池，类模板。</p>
</li>
<li>
<p>方法区逻辑上定义为在堆中。</p>
<p>1.8以前叫永久代，用的堆。</p>
<p>1.8以后用叫元空间，用的操作系统内存。StringTable串池还是在堆中</p>
</li>
<li>
<p>方法区也会内存溢出</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="022_%e6%96%b9%e6%b3%95%e5%8c%ba%e5%ae%9a%e4%b9%89.png"
        data-srcset="022_%e6%96%b9%e6%b3%95%e5%8c%ba%e5%ae%9a%e4%b9%89.png, 022_%e6%96%b9%e6%b3%95%e5%8c%ba%e5%ae%9a%e4%b9%89.png 1.5x, 022_%e6%96%b9%e6%b3%95%e5%8c%ba%e5%ae%9a%e4%b9%89.png 2x"
        data-sizes="auto"
        alt="022_方法区定义.png"
        title="022_方法区定义.png" /></p>
</li>
</ul>
<h4 id="内存溢出-1">内存溢出</h4>
<p>jvm参数： -XX:MaxMetaspaceSize=8m</p>
<p>1.8 以前会导致永久代内存溢出</p>
<ul>
<li>演示永久代内存溢出 java.lang.OutOfMemoryError: PermGen space</li>
<li>-XX:MaxPermSize=8m</li>
</ul>
<p>1.8 之后会导致元空间内存溢出</p>
<ul>
<li>
<p>演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace</p>
</li>
<li>
<p>-XX:MaxMetaspaceSize=8m</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace
</span></span><span class="line"><span class="cl"> * 元空间 大小参数设置
</span></span><span class="line"><span class="cl"> * -XX:MaxMetaspaceSize=8m
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">public class Demo1_8 extends ClassLoader { // 可以用来加载类的二进制字节码
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        int j = 0;
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            Demo1_8 test = new Demo1_8();
</span></span><span class="line"><span class="cl">            for (int i = 0; i &lt; 10000; i++, j++) {
</span></span><span class="line"><span class="cl">                // ClassWriter 作用是生成类的二进制字节码
</span></span><span class="line"><span class="cl">                ClassWriter cw = new ClassWriter(0);
</span></span><span class="line"><span class="cl">                //参数定义: 版本号， public， 类名, 包名, 父类， 接口
</span></span><span class="line"><span class="cl">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, &#34;Class&#34; + i, null, &#34;java/lang/Object&#34;, null);
</span></span><span class="line"><span class="cl">                // 返回 byte[]
</span></span><span class="line"><span class="cl">                byte[] code = cw.toByteArray();
</span></span><span class="line"><span class="cl">                // 执行了类的加载
</span></span><span class="line"><span class="cl">                test.defineClass(&#34;Class&#34; + i, code, 0, code.length); // Class 对象
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        } finally {
</span></span><span class="line"><span class="cl">            System.out.println(j);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>工作中加载类的场景</p>
<ul>
<li>
<p>spring</p>
</li>
<li>
<p>mybatis</p>
</li>
</ul>
<h4 id="常量池">常量池</h4>
<h5 id="定义-4">定义</h5>
<ul>
<li>
<p>常量池</p>
<p>就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量（即参数，字符串，布尔类型，整形）信息</p>
</li>
<li>
<p>运行时常量池
常量池是*.class文件中的，当该<strong>类被加载以后</strong>，它的常量池信息就会放入运行时常量池（也就是内存中），并把里面的符号地址变为真实地址。(即#1，#2变成物理地址)</p>
</li>
</ul>
<h5 id="举例说明">举例说明</h5>
<p>用java代码反编译举个例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> // 二进制字节码（类基本信息，常量池，类方法定义，包含了虚拟机指令）
</span></span><span class="line"><span class="cl"> public class HelloWorld {
</span></span><span class="line"><span class="cl">     public static void main(String[] args) {
</span></span><span class="line"><span class="cl">         System.out.println(&#34;hello world&#34;);
</span></span><span class="line"><span class="cl">     }
</span></span><span class="line"><span class="cl"> }
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>javap -v HelloWorld.class</p>
<p>反编译</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">========================类基本信息========================
</span></span><span class="line"><span class="cl">  Last modified 2022-10-14; size 567 bytes
</span></span><span class="line"><span class="cl">  MD5 checksum 8efebdac91aa496515fa1c161184e354
</span></span><span class="line"><span class="cl">  Compiled from &#34;HelloWorld.java&#34;
</span></span><span class="line"><span class="cl">public class cn.itcast.jvm.t5.HelloWorld
</span></span><span class="line"><span class="cl">  minor version: 0
</span></span><span class="line"><span class="cl">  major version: 52
</span></span><span class="line"><span class="cl">  flags: ACC_PUBLIC, ACC_SUPER
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">========================常量池========================
</span></span><span class="line"><span class="cl">Constant pool:
</span></span><span class="line"><span class="cl">   #1 = Methodref          #6.#20         // java/lang/Object.&#34;&lt;init&gt;&#34;:()V
</span></span><span class="line"><span class="cl">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;
</span></span><span class="line"><span class="cl">   #3 = String             #23            // hello world
</span></span><span class="line"><span class="cl">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V
</span></span><span class="line"><span class="cl">   #5 = Class              #26            // cn/itcast/jvm/t5/HelloWorld
</span></span><span class="line"><span class="cl">   #6 = Class              #27            // java/lang/Object
</span></span><span class="line"><span class="cl">   #7 = Utf8               &lt;init&gt;
</span></span><span class="line"><span class="cl">   #8 = Utf8               ()V
</span></span><span class="line"><span class="cl">   #9 = Utf8               Code
</span></span><span class="line"><span class="cl">  #10 = Utf8               LineNumberTable
</span></span><span class="line"><span class="cl">  #11 = Utf8               LocalVariableTable
</span></span><span class="line"><span class="cl">  #12 = Utf8               this
</span></span><span class="line"><span class="cl">  #13 = Utf8               Lcn/itcast/jvm/t5/HelloWorld;
</span></span><span class="line"><span class="cl">  #14 = Utf8               main
</span></span><span class="line"><span class="cl">  #15 = Utf8               ([Ljava/lang/String;)V
</span></span><span class="line"><span class="cl">  #16 = Utf8               args
</span></span><span class="line"><span class="cl">  #17 = Utf8               [Ljava/lang/String;
</span></span><span class="line"><span class="cl">  #18 = Utf8               SourceFile
</span></span><span class="line"><span class="cl">  #19 = Utf8               HelloWorld.java
</span></span><span class="line"><span class="cl">  #20 = NameAndType        #7:#8          // &#34;&lt;init&gt;&#34;:()V
</span></span><span class="line"><span class="cl">  #21 = Class              #28            // java/lang/System
</span></span><span class="line"><span class="cl">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;
</span></span><span class="line"><span class="cl">  #23 = Utf8               hello world
</span></span><span class="line"><span class="cl">  #24 = Class              #31            // java/io/PrintStream
</span></span><span class="line"><span class="cl">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V
</span></span><span class="line"><span class="cl">  #26 = Utf8               cn/itcast/jvm/t5/HelloWorld
</span></span><span class="line"><span class="cl">  #27 = Utf8               java/lang/Object
</span></span><span class="line"><span class="cl">  #28 = Utf8               java/lang/System
</span></span><span class="line"><span class="cl">  #29 = Utf8               out
</span></span><span class="line"><span class="cl">  #30 = Utf8               Ljava/io/PrintStream;
</span></span><span class="line"><span class="cl">  #31 = Utf8               java/io/PrintStream
</span></span><span class="line"><span class="cl">  #32 = Utf8               println
</span></span><span class="line"><span class="cl">  #33 = Utf8               (Ljava/lang/String;)V
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">========================类方法定义========================
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  public cn.itcast.jvm.t5.HelloWorld();       //构造方法
</span></span><span class="line"><span class="cl">    descriptor: ()V
</span></span><span class="line"><span class="cl">    flags: ACC_PUBLIC
</span></span><span class="line"><span class="cl">    Code:
</span></span><span class="line"><span class="cl">      stack=1, locals=1, args_size=1
</span></span><span class="line"><span class="cl">         0: aload_0
</span></span><span class="line"><span class="cl">         1: invokespecial #1                  // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
</span></span><span class="line"><span class="cl">         4: return
</span></span><span class="line"><span class="cl">      LineNumberTable:
</span></span><span class="line"><span class="cl">        line 4: 0
</span></span><span class="line"><span class="cl">      LocalVariableTable:
</span></span><span class="line"><span class="cl">        Start  Length  Slot  Name   Signature
</span></span><span class="line"><span class="cl">            0       5     0  this   Lcn/itcast/jvm/t5/HelloWorld;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  public static void main(java.lang.String[]);    //main 方法
</span></span><span class="line"><span class="cl">    descriptor: ([Ljava/lang/String;)V
</span></span><span class="line"><span class="cl">    flags: ACC_PUBLIC, ACC_STATIC
</span></span><span class="line"><span class="cl">    Code:
</span></span><span class="line"><span class="cl">      stack=2, locals=1, args_size=1
</span></span><span class="line"><span class="cl">         0: getstatic     #2                  // 获取System.out这个静态变量
</span></span><span class="line"><span class="cl">         3: ldc           #3                  // String hello world 加载一个参数
</span></span><span class="line"><span class="cl">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V 虚方法调用
</span></span><span class="line"><span class="cl">         8: return
</span></span><span class="line"><span class="cl">      LineNumberTable:
</span></span><span class="line"><span class="cl">        line 6: 0
</span></span><span class="line"><span class="cl">        line 7: 8
</span></span><span class="line"><span class="cl">      LocalVariableTable:
</span></span><span class="line"><span class="cl">        Start  Length  Slot  Name   Signature
</span></span><span class="line"><span class="cl">            0       9     0  args   [Ljava/lang/String;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">SourceFile: &#34;HelloWorld.java&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th>翻译下就是</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>getstatic #2</td>
<td>去常量池(Constant pool）找 #2 的变量,最终找到了System.out这个静态成员变量</td>
</tr>
<tr>
<td></td>
<td>#2 = Fieldref 是一个成员变量的引用</td>
</tr>
<tr>
<td></td>
<td>#2-&gt;#21.#22</td>
</tr>
<tr>
<td></td>
<td>#21 = Class              #28</td>
</tr>
<tr>
<td></td>
<td>#22 = NameAndType        #29:#30</td>
</tr>
<tr>
<td></td>
<td>#28 = Utf8               java/lang/System</td>
</tr>
<tr>
<td></td>
<td>#29 = Utf8               out</td>
</tr>
<tr>
<td></td>
<td>#30 = Utf8               Ljava/io/PrintStream;</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>ldc           #3</td>
<td>#3 = String             #23</td>
</tr>
<tr>
<td></td>
<td>#23 = Utf8               hello world</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>invokevirtual #4</td>
<td>找到 java/io/PrintStream对象的println方法 参数是:(Ljava/lang/String;)V，并调用</td>
</tr>
<tr>
<td></td>
<td>#4 = Methodref          #24.#25</td>
</tr>
<tr>
<td></td>
<td>#24 = Class              #31</td>
</tr>
<tr>
<td></td>
<td>#25 = NameAndType        #32:#33</td>
</tr>
<tr>
<td></td>
<td>#31 = Utf8               java/io/PrintStream</td>
</tr>
<tr>
<td></td>
<td>#32 = Utf8               println</td>
</tr>
<tr>
<td></td>
<td>#33 = Utf8               (Ljava/lang/String;)V</td>
</tr>
</tbody>
</table>
<h4 id="stringtable串池">StringTable（串池）</h4>
<p>常量池-&gt;运行时常量池-</p>
<p>执行语句 String str = &ldquo;abc&rdquo; 时，首先查看字符串池中是否存在字符串&quot;abc&quot; ，如果存在则直接将&quot;abc&quot;地址赋给str ，如果不存在则先在字符串池中新建一个字符串&quot;abc&quot;，然后再将其赋给str。</p>
<p>String str = new String(“aa”)：至少会创建一个对象，也有可能创建两个。用到new关键字，肯定会在堆中创建一个String对象，如果字符池中已经存在”abc”,则不会在字符串池中创建一个String对象，如果不存在，则会在字符串常量池中也创建一个对象。</p>
<p>直到用到了该符号，才会创建对应的字符串对象放入字符串常量池</p>
<h5 id="举例说明依据字节码">举例说明(依据字节码)</h5>
<p>java代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// StringTable [ &#34;a&#34;, &#34;b&#34; ,&#34;ab&#34; ]  hashtable 结构，不能扩容
</span></span><span class="line"><span class="cl">public class Demo1_22 {
</span></span><span class="line"><span class="cl">    // 常量池中的信息，都会被加载到运行时常量池中， 这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象
</span></span><span class="line"><span class="cl">    // ldc #2 会把 a 符号变为 &#34;a&#34; 字符串对象
</span></span><span class="line"><span class="cl">    // ldc #3 会把 b 符号变为 &#34;b&#34; 字符串对象
</span></span><span class="line"><span class="cl">    // ldc #4 会把 ab 符号变为 &#34;ab&#34; 字符串对象
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        String s1 = &#34;a&#34;; // 懒惰的
</span></span><span class="line"><span class="cl">        String s2 = &#34;b&#34;;
</span></span><span class="line"><span class="cl">        String s3 = &#34;ab&#34;;
</span></span><span class="line"><span class="cl">        String s4 = s1 + s2; //通过字节码可以知道，实际上是 new StringBuilder().append(&#34;a&#34;).append(&#34;b&#34;).toString() 和  new String(&#34;ab&#34;)
</span></span><span class="line"><span class="cl">        System.out.println(s3 == s4);// false  因为s3在串池，s4在堆中
</span></span><span class="line"><span class="cl">        String s5 = &#34;a&#34; + &#34;b&#34;;  // javac 在编译期间的优化，结果已经在编译期确定为ab
</span></span><span class="line"><span class="cl">        System.out.println(s3 == s5);//true 因为都是在串池
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>java字节码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Classfile /G:/xrqProjects/jvm/代码/jvm/out/production/jvm/cn/itcast/jvm/t1/stringtable/Demo1_22.class
</span></span><span class="line"><span class="cl">  Last modified 2022-10-17; size 1057 bytes
</span></span><span class="line"><span class="cl">  MD5 checksum b94bb46c9f03f10beb6d57556ca42557
</span></span><span class="line"><span class="cl">  Compiled from &#34;Demo1_22.java&#34;
</span></span><span class="line"><span class="cl">public class cn.itcast.jvm.t1.stringtable.Demo1_22
</span></span><span class="line"><span class="cl">  minor version: 0
</span></span><span class="line"><span class="cl">  major version: 52
</span></span><span class="line"><span class="cl">  flags: ACC_PUBLIC, ACC_SUPER
</span></span><span class="line"><span class="cl">Constant pool:
</span></span><span class="line"><span class="cl">   #1 = Methodref          #12.#36        // java/lang/Object.&#34;&lt;init&gt;&#34;:()V
</span></span><span class="line"><span class="cl">   #2 = String             #37            // a
</span></span><span class="line"><span class="cl">   #3 = String             #38            // b
</span></span><span class="line"><span class="cl">   #4 = String             #39            // ab
</span></span><span class="line"><span class="cl">   #5 = Class              #40            // java/lang/StringBuilder
</span></span><span class="line"><span class="cl">   #6 = Methodref          #5.#36         // java/lang/StringBuilder.&#34;&lt;init&gt;&#34;:()V
</span></span><span class="line"><span class="cl">   #7 = Methodref          #5.#41         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
</span></span><span class="line"><span class="cl">   #8 = Methodref          #5.#42         // java/lang/StringBuilder.toString:()Ljava/lang/String;
</span></span><span class="line"><span class="cl">   #9 = Fieldref           #43.#44        // java/lang/System.out:Ljava/io/PrintStream;
</span></span><span class="line"><span class="cl">  #10 = Methodref          #45.#46        // java/io/PrintStream.println:(Z)V
</span></span><span class="line"><span class="cl">  #11 = Class              #47            // cn/itcast/jvm/t1/stringtable/Demo1_22
</span></span><span class="line"><span class="cl">  #12 = Class              #48            // java/lang/Object
</span></span><span class="line"><span class="cl">  #13 = Utf8               &lt;init&gt;
</span></span><span class="line"><span class="cl">  #14 = Utf8               ()V
</span></span><span class="line"><span class="cl">  #15 = Utf8               Code
</span></span><span class="line"><span class="cl">  #16 = Utf8               LineNumberTable
</span></span><span class="line"><span class="cl">  #17 = Utf8               LocalVariableTable
</span></span><span class="line"><span class="cl">  #18 = Utf8               this
</span></span><span class="line"><span class="cl">  #19 = Utf8               Lcn/itcast/jvm/t1/stringtable/Demo1_22;
</span></span><span class="line"><span class="cl">  #20 = Utf8               main
</span></span><span class="line"><span class="cl">  #21 = Utf8               ([Ljava/lang/String;)V
</span></span><span class="line"><span class="cl">  #22 = Utf8               args
</span></span><span class="line"><span class="cl">  #23 = Utf8               [Ljava/lang/String;
</span></span><span class="line"><span class="cl">  #24 = Utf8               s1
</span></span><span class="line"><span class="cl">  #25 = Utf8               Ljava/lang/String;
</span></span><span class="line"><span class="cl">  #26 = Utf8               s2
</span></span><span class="line"><span class="cl">  #27 = Utf8               s3
</span></span><span class="line"><span class="cl">  #28 = Utf8               s4
</span></span><span class="line"><span class="cl">  #29 = Utf8               s5
</span></span><span class="line"><span class="cl">  #30 = Utf8               StackMapTable
</span></span><span class="line"><span class="cl">  #31 = Class              #23            // &#34;[Ljava/lang/String;&#34;
</span></span><span class="line"><span class="cl">  #32 = Class              #49            // java/lang/String
</span></span><span class="line"><span class="cl">  #33 = Class              #50            // java/io/PrintStream
</span></span><span class="line"><span class="cl">  #34 = Utf8               SourceFile
</span></span><span class="line"><span class="cl">  #35 = Utf8               Demo1_22.java
</span></span><span class="line"><span class="cl">  #36 = NameAndType        #13:#14        // &#34;&lt;init&gt;&#34;:()V
</span></span><span class="line"><span class="cl">  #37 = Utf8               a
</span></span><span class="line"><span class="cl">  #38 = Utf8               b
</span></span><span class="line"><span class="cl">  #39 = Utf8               ab
</span></span><span class="line"><span class="cl">  #40 = Utf8               java/lang/StringBuilder
</span></span><span class="line"><span class="cl">  #41 = NameAndType        #51:#52        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
</span></span><span class="line"><span class="cl">  #42 = NameAndType        #53:#54        // toString:()Ljava/lang/String;
</span></span><span class="line"><span class="cl">  #43 = Class              #55            // java/lang/System
</span></span><span class="line"><span class="cl">  #44 = NameAndType        #56:#57        // out:Ljava/io/PrintStream;
</span></span><span class="line"><span class="cl">  #45 = Class              #50            // java/io/PrintStream
</span></span><span class="line"><span class="cl">  #46 = NameAndType        #58:#59        // println:(Z)V
</span></span><span class="line"><span class="cl">  #47 = Utf8               cn/itcast/jvm/t1/stringtable/Demo1_22
</span></span><span class="line"><span class="cl">  #48 = Utf8               java/lang/Object
</span></span><span class="line"><span class="cl">  #49 = Utf8               java/lang/String
</span></span><span class="line"><span class="cl">  #50 = Utf8               java/io/PrintStream
</span></span><span class="line"><span class="cl">  #51 = Utf8               append
</span></span><span class="line"><span class="cl">  #52 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;
</span></span><span class="line"><span class="cl">  #53 = Utf8               toString
</span></span><span class="line"><span class="cl">  #54 = Utf8               ()Ljava/lang/String;
</span></span><span class="line"><span class="cl">  #55 = Utf8               java/lang/System
</span></span><span class="line"><span class="cl">  #56 = Utf8               out
</span></span><span class="line"><span class="cl">  #57 = Utf8               Ljava/io/PrintStream;
</span></span><span class="line"><span class="cl">  #58 = Utf8               println
</span></span><span class="line"><span class="cl">  #59 = Utf8               (Z)V
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  public cn.itcast.jvm.t1.stringtable.Demo1_22();
</span></span><span class="line"><span class="cl">    descriptor: ()V
</span></span><span class="line"><span class="cl">    flags: ACC_PUBLIC
</span></span><span class="line"><span class="cl">    Code:
</span></span><span class="line"><span class="cl">      stack=1, locals=1, args_size=1
</span></span><span class="line"><span class="cl">         0: aload_0
</span></span><span class="line"><span class="cl">         1: invokespecial #1                  // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
</span></span><span class="line"><span class="cl">         4: return
</span></span><span class="line"><span class="cl">      LineNumberTable:
</span></span><span class="line"><span class="cl">        line 4: 0
</span></span><span class="line"><span class="cl">      LocalVariableTable:
</span></span><span class="line"><span class="cl">        Start  Length  Slot  Name   Signature
</span></span><span class="line"><span class="cl">            0       5     0  this   Lcn/itcast/jvm/t1/stringtable/Demo1_22;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  public static void main(java.lang.String[]);
</span></span><span class="line"><span class="cl">    descriptor: ([Ljava/lang/String;)V
</span></span><span class="line"><span class="cl">    flags: ACC_PUBLIC, ACC_STATIC
</span></span><span class="line"><span class="cl">    Code:
</span></span><span class="line"><span class="cl">      stack=3, locals=6, args_size=1
</span></span><span class="line"><span class="cl">         0: ldc           #2                  // String a
</span></span><span class="line"><span class="cl">         2: astore_1
</span></span><span class="line"><span class="cl">         3: ldc           #3                  // String b
</span></span><span class="line"><span class="cl">         5: astore_2
</span></span><span class="line"><span class="cl">         6: ldc           #4                  // String ab  s3 == s5 为true!!!!!!!!!!!!!!!!!!!!!
</span></span><span class="line"><span class="cl">         8: astore_3
</span></span><span class="line"><span class="cl">         9: new           #5                  // class java/lang/StringBuilder
</span></span><span class="line"><span class="cl">        12: dup
</span></span><span class="line"><span class="cl">        13: invokespecial #6                  // Method java/lang/StringBuilder.&#34;&lt;init&gt;&#34;:()V
</span></span><span class="line"><span class="cl">        16: aload_1
</span></span><span class="line"><span class="cl">        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
</span></span><span class="line"><span class="cl">        20: aload_2
</span></span><span class="line"><span class="cl">        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
</span></span><span class="line"><span class="cl">        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
</span></span><span class="line"><span class="cl">        27: astore        4
</span></span><span class="line"><span class="cl">        29: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;
</span></span><span class="line"><span class="cl">        32: aload_3
</span></span><span class="line"><span class="cl">        33: aload         4
</span></span><span class="line"><span class="cl">        35: if_acmpne     42
</span></span><span class="line"><span class="cl">        38: iconst_1
</span></span><span class="line"><span class="cl">        39: goto          43
</span></span><span class="line"><span class="cl">        42: iconst_0
</span></span><span class="line"><span class="cl">        43: invokevirtual #10                 // Method java/io/PrintStream.println:(Z)V
</span></span><span class="line"><span class="cl">        46: ldc           #4                  // String ab    s3 == s5 为true!!!!!!!!!!!!!!!!!!!!!
</span></span><span class="line"><span class="cl">        48: astore        5
</span></span><span class="line"><span class="cl">        50: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;
</span></span><span class="line"><span class="cl">        53: aload_3
</span></span><span class="line"><span class="cl">        54: aload         5
</span></span><span class="line"><span class="cl">        56: if_acmpne     63
</span></span><span class="line"><span class="cl">        59: iconst_1
</span></span><span class="line"><span class="cl">        60: goto          64
</span></span><span class="line"><span class="cl">        63: iconst_0
</span></span><span class="line"><span class="cl">        64: invokevirtual #10                 // Method java/io/PrintStream.println:(Z)V
</span></span><span class="line"><span class="cl">        67: return
</span></span><span class="line"><span class="cl">      LineNumberTable:
</span></span><span class="line"><span class="cl">        line 11: 0
</span></span><span class="line"><span class="cl">        line 12: 3
</span></span><span class="line"><span class="cl">        line 13: 6
</span></span><span class="line"><span class="cl">        line 14: 9
</span></span><span class="line"><span class="cl">        line 15: 29
</span></span><span class="line"><span class="cl">        line 16: 46
</span></span><span class="line"><span class="cl">        line 17: 50
</span></span><span class="line"><span class="cl">        line 19: 67
</span></span><span class="line"><span class="cl">      LocalVariableTable:
</span></span><span class="line"><span class="cl">        Start  Length  Slot  Name   Signature
</span></span><span class="line"><span class="cl">            0      68     0  args   [Ljava/lang/String;
</span></span><span class="line"><span class="cl">            3      65     1    s1   Ljava/lang/String;
</span></span><span class="line"><span class="cl">            6      62     2    s2   Ljava/lang/String;
</span></span><span class="line"><span class="cl">            9      59     3    s3   Ljava/lang/String;
</span></span><span class="line"><span class="cl">           29      39     4    s4   Ljava/lang/String;
</span></span><span class="line"><span class="cl">           50      18     5    s5   Ljava/lang/String;
</span></span><span class="line"><span class="cl">      StackMapTable: number_of_entries = 4
</span></span><span class="line"><span class="cl">        frame_type = 255 /* full_frame */
</span></span><span class="line"><span class="cl">          offset_delta = 42
</span></span><span class="line"><span class="cl">          locals = [ class &#34;[Ljava/lang/String;&#34;, class java/lang/String, class java/lang/String, class java/lang/String, class java/lang/String ]
</span></span><span class="line"><span class="cl">          stack = [ class java/io/PrintStream ]
</span></span><span class="line"><span class="cl">        frame_type = 255 /* full_frame */
</span></span><span class="line"><span class="cl">          offset_delta = 0
</span></span><span class="line"><span class="cl">          locals = [ class &#34;[Ljava/lang/String;&#34;, class java/lang/String, class java/lang/String, class java/lang/String, class java/lang/String ]
</span></span><span class="line"><span class="cl">          stack = [ class java/io/PrintStream, int ]
</span></span><span class="line"><span class="cl">        frame_type = 255 /* full_frame */
</span></span><span class="line"><span class="cl">          offset_delta = 19
</span></span><span class="line"><span class="cl">          locals = [ class &#34;[Ljava/lang/String;&#34;, class java/lang/String, class java/lang/String, class java/lang/String, class java/lang/String, class java/lang/String ]
</span></span><span class="line"><span class="cl">          stack = [ class java/io/PrintStream ]
</span></span><span class="line"><span class="cl">        frame_type = 255 /* full_frame */
</span></span><span class="line"><span class="cl">          offset_delta = 0
</span></span><span class="line"><span class="cl">          locals = [ class &#34;[Ljava/lang/String;&#34;, class java/lang/String, class java/lang/String, class java/lang/String, class java/lang/String, class java/lang/String ]
</span></span><span class="line"><span class="cl">          stack = [ class java/io/PrintStream, int ]
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">SourceFile: &#34;Demo1_22.java&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="特征">特征</h5>
<ul>
<li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li>
<li>利用串池的机制，来避免重复创建字符串对象</li>
<li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li>
<li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li>
<li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li>
<li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li>
</ul>
<h5 id="intern方法-18">intern方法 1.8</h5>
<p>调用字符串对象的intern方法，会将该字符串对象<strong>的引用</strong>尝试放入到串池中</p>
<ul>
<li>
<p>如果串池中没有该字符串对象，则放入</p>
</li>
<li>
<p>如果有该字符串对象，则不会放入</p>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
</li>
</ul>
<p>JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">例子1：先创建堆字符串，再intern()
</span></span><span class="line"><span class="cl">public static void main(String[] args) {
</span></span><span class="line"><span class="cl">    //串池：【&#34;a&#34; &#34;b&#34;】,堆：【new String(&#34;a&#34;)，new String(&#34;b&#34;), new String(&#34;ab&#34;)】
</span></span><span class="line"><span class="cl">    String s = new String(&#34;a&#34;) + new String(&#34;b&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //调用intern方法，这时串池中没有&#34;ab&#34;，则会将s这个对象引用放入到串池中，此时堆内存与串池中的&#34;ab&#34;是同一个字符串对象的引用
</span></span><span class="line"><span class="cl">    String s2 = s.intern();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //与串池中的ab对象做比较 返回true
</span></span><span class="line"><span class="cl">    System.out.println(s2 == &#34;ab&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //比较的是引用 返回true  jdk1.6这里是false
</span></span><span class="line"><span class="cl">    System.out.println(s == &#34;ab&#34;);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">例子2：先创建串池字符串，后创建堆中字符串，再intern()
</span></span><span class="line"><span class="cl">public static void main(String[] args) {
</span></span><span class="line"><span class="cl">    //串池：【&#34;ab&#34;】
</span></span><span class="line"><span class="cl">    String x = &#34;ab&#34;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //串池：【&#34;ab&#34;,&#34;a&#34; &#34;b&#34;】,这一步只是添加了【&#34;a&#34; &#34;b&#34;】
</span></span><span class="line"><span class="cl">    //并且在堆中创建了 s对象 ，s和x不是同一个对象，因为是串池中的“ab”先创建，堆中拼接后创建
</span></span><span class="line"><span class="cl">    String s = new String(&#34;a&#34;) + new String(&#34;b&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //串池中已经有ab了，所以s被没有被放进去，返回的是串池中的对象
</span></span><span class="line"><span class="cl">    String s2 = s.intern();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //s2和x都是串池中的对象 返回true
</span></span><span class="line"><span class="cl">    System.out.println(s2 == x);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //s是堆中的对象 x串池中对象 返回false
</span></span><span class="line"><span class="cl">    System.out.println(s == x);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="intern方法-16">intern方法 1.6</h5>
<p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，<strong>会将该字符串对象复制一份</strong>，再放入到串池中</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong>，上面例子1中  System.out.println(s== &ldquo;ab&rdquo;);返回false</p>
<h5 id="垃圾回收">垃圾回收</h5>
<p>StringTable在内存紧张时，会发生垃圾回收</p>
<p>在jvm1.6中，StringTable是常量池的一部分。</p>
<p>在jvm1.8中，StringTable存在了堆中。</p>
<p>为什么要变呢？因为永久代是在full gc的时候，才会gc。触发的时间比较慢。导致StringTable 回收效率不高。但StringTable 使用频繁，如java程序中会大量使用字符串常量。回收效率不高会占用大量内存，有可能会导致永久代内存不足。在堆中只要minor gc就会触发gc。</p>
<p>注意：</p>
<p>1.6永久代和堆逻辑上是相互隔离的，但它们使用的物理内存是连续的。</p>
<p>1.8元空间不再与堆连续，而且是存在于本地内存（Native memory）</p>
<p><a href="https://blog.csdn.net/ju_362204801/article/details/122379813" target="_blank" rel="noopener noreffer">https://blog.csdn.net/ju_362204801/article/details/122379813</a>
</p>
<h5 id="stringtable调优">StringTable调优</h5>
<ul>
<li>StringTable是由类似juc里的HashTable实现的，所以可以<strong>适当增加桶的个数</strong>，从而减少哈希碰撞，来减少字符串放入串池所需要的时间。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-XX:StringTableSize=20000
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果有大量的字符串，并且有不少是重复的，可以通过intern方法减去重后入池，减少内存占用。因为在串池中，相同的字符串在串池只会存储一份。</li>
</ul>
<h4 id="直接内存">直接内存</h4>
<ul>
<li>
<p>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></p>
</li>
<li>
<p>分配回收成本较高，但读写性能高</p>
</li>
<li>
<p>不受JVM内存回收管理</p>
</li>
<li>
<p>java 想要读取文件时，需要从用户态切换到内核态，通过内核态将文件先读取到系统缓冲区，再读取到java缓冲区。</p>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="042_%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ad%98_Io.png"
        data-srcset="042_%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ad%98_Io.png, 042_%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ad%98_Io.png 1.5x, 042_%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ad%98_Io.png 2x"
        data-sizes="auto"
        alt="042_直接内存_Io.png"
        title="042_直接内存_Io.png" /></p>
<ul>
<li>直接内存是操作系统和Java代码都可以访问的一块区域，无需将代码从系统内存复制到Java堆内存，从而提高了效率。比如nio中的ByteBuffer.allocateDirect(16)。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="042_%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ae%b9_nio.png"
        data-srcset="042_%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ae%b9_nio.png, 042_%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ae%b9_nio.png 1.5x, 042_%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ae%b9_nio.png 2x"
        data-sizes="auto"
        alt="042_直接内容_nio.png"
        title="042_直接内容_nio.png" /></p>
<ul>
<li>class java.nio.HeapByteBuffer          -java 堆内存，读写效率较低 ，就和普通javabean 对象一会受到GC影响</li>
<li>class java.nio.DirectByteBuffer        -直接内存 ，读写效率高（少一次拷贝），不会受到java GC的影响，分配内存效率低,但是也会有内存溢出的限制。</li>
</ul>
<h5 id="释放原理">释放原理</h5>
<p>java.nio.DirectByteBuffer 直接内存的回收不是通过JVM的垃圾回收来释放的，而是最终通过<strong>unsafe.freeMemory</strong>来手动释放</p>
<ul>
<li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li>
<li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li>
<li>如果java中 ByteBuffer对象没有垃圾回收，和它关联的直接内存对象不会自动回收，需要通过<strong>unsafe.freeMemory</strong>来手动释放</li>
</ul>
<p>通过 ByteBuffer.allocateDirect 得到DirectByteBuffer</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ByteBuffer bb = ByteBuffer.allocateDirect(1024 * 1024)
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> DirectByteBuffer(int cap) {                   // package-private
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        super(-1, 0, cap, cap);
</span></span><span class="line"><span class="cl">        boolean pa = VM.isDirectMemoryPageAligned();
</span></span><span class="line"><span class="cl">        int ps = Bits.pageSize();
</span></span><span class="line"><span class="cl">        long size = Math.max(1L, (long)cap + (pa ? ps : 0));
</span></span><span class="line"><span class="cl">        Bits.reserveMemory(size, cap);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        long base = 0;
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            base = unsafe.allocateMemory(size);// 分配了DirectByteBuffer对象的直接内存！！！！！！！！！！！！！！！
</span></span><span class="line"><span class="cl">        } catch (OutOfMemoryError x) {
</span></span><span class="line"><span class="cl">            Bits.unreserveMemory(size, cap);
</span></span><span class="line"><span class="cl">            throw x;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        unsafe.setMemory(base, size, (byte) 0);
</span></span><span class="line"><span class="cl">        if (pa &amp;&amp; (base % ps != 0)) {
</span></span><span class="line"><span class="cl">            // Round up to page boundary
</span></span><span class="line"><span class="cl">            address = base + ps - (base &amp; (ps - 1));
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            address = base;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        //Cleaner是个虚引用类型 Cleaner extends PhantomReference&lt;Object&gt;，当它所关联的对象被gc时，会触发它的clean方法。也就是this对象触发gc时，会调用Cleaner 的clean方法。
</span></span><span class="line"><span class="cl">        //本例中就是调用Deallocator里的 run方法 用unsafe 方式进行直接内存的回收
</span></span><span class="line"><span class="cl">        //在后台有个专门检测虚引用对象的ReferenceHandler线程中 执行clean方法。
</span></span><span class="line"><span class="cl">        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));//
</span></span><span class="line"><span class="cl">        att = null;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>回调任务对象Deallocator会释放DirectByteBuffer对象的直接内存！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> #Cleaner的 回调任务对象 
</span></span><span class="line"><span class="cl"> private static class Deallocator
</span></span><span class="line"><span class="cl">        implements Runnable
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        private static Unsafe unsafe = Unsafe.getUnsafe();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        private long address;
</span></span><span class="line"><span class="cl">        private long size;
</span></span><span class="line"><span class="cl">        private int capacity;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        private Deallocator(long address, long size, int capacity) {
</span></span><span class="line"><span class="cl">            assert (address != 0);
</span></span><span class="line"><span class="cl">            this.address = address;
</span></span><span class="line"><span class="cl">            this.size = size;
</span></span><span class="line"><span class="cl">            this.capacity = capacity;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        public void run() {
</span></span><span class="line"><span class="cl">            if (address == 0) {
</span></span><span class="line"><span class="cl">                // Paranoia
</span></span><span class="line"><span class="cl">                return;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            unsafe.freeMemory(address);// 释放了DirectByteBuffer对象的直接内存！！！！！！！！！！！！！！！
</span></span><span class="line"><span class="cl">            address = 0;
</span></span><span class="line"><span class="cl">            Bits.unreserveMemory(size, capacity);      
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="三垃圾回收">三、垃圾回收</h2>
<h3 id="1如何判断对象可以回收">1、如何判断对象可以回收</h3>
<h4 id="引用计数法">引用计数法</h4>
<p>只要这个对象被其他对象引用就 计数加一，不再被引用就减一。0代表可以回收。</p>
<p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p>
<h4 id="可达性分析算法jvm使用的">可达性分析算法（JVM使用的）</h4>
<ul>
<li>
<p>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</p>
</li>
<li>
<p>扫描 <strong>堆</strong> 中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></p>
<p>例子：抓住葡萄的根，连着的葡萄就是不可垃圾回收的对象，落下的葡萄就是可垃圾回收的对象</p>
</li>
</ul>
<h4 id="可以作为gc-root的对象">可以作为GC Root的对象</h4>
<p>-指肯定不能被垃圾回收 的对象</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
<li>被synchronized关键字持有的对象</li>
</ul>
<h4 id="五种引用">五种引用</h4>
<h5 id="引用队列的作用">引用队列的作用</h5>
<p>回收软引用或者弱引用本身</p>
<p>回收虚引用本身，并且释放直接内存</p>
<p>回收终结器引用，对象被垃圾回收，会加入引用队列，但是还不能被直接垃圾回收</p>
<h5 id="软引用或者弱引是怎么被回收的">软引用或者弱引是怎么被回收的</h5>
<p>就比如ByteBuffer对象会被jvm gc回收掉，但包装ByteBuffer对象的SoftReference对象不会被马上回收，要配合引用队列回收</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="054_5%e7%a7%8d%e5%bc%95%e7%94%a8.png"
        data-srcset="054_5%e7%a7%8d%e5%bc%95%e7%94%a8.png, 054_5%e7%a7%8d%e5%bc%95%e7%94%a8.png 1.5x, 054_5%e7%a7%8d%e5%bc%95%e7%94%a8.png 2x"
        data-sizes="auto"
        alt="054_5种引用.png"
        title="054_5种引用.png" /></p>
<h5 id="强引用">强引用</h5>
<p>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p>
<ul>
<li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li>
</ul>
<p><!-- raw HTML omitted -->以下引用的前提:没有强引用引用该对象<!-- raw HTML omitted --></p>
<h5 id="软引用">软引用</h5>
<p>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收<strong>软引用对象所引用的对象</strong></p>
<ul>
<li>
<p>可以配合引用队列来释放软引用自身</p>
</li>
<li>
<p>当GC Root指向软引用对象，软引用对象引用了一个对象，在触发了垃圾回收,且内存不足时，会<strong>回收软引用所引用的对象</strong></p>
</li>
</ul>
<p>就如 list &ndash;&gt; SoftReference &ndash;&gt; byte[]</p>
<ul>
<li>如上图如果B对象不再引用 且 A2对象且内存不足时，软引用所引用的A2对象就会被回收</li>
<li>反射中的一些方法就用到了软引用</li>
</ul>
<p>软引用的使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">import java.io.IOException;
</span></span><span class="line"><span class="cl">import java.lang.ref.SoftReference;
</span></span><span class="line"><span class="cl">import java.util.ArrayList;
</span></span><span class="line"><span class="cl">import java.util.List;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 演示软引用
</span></span><span class="line"><span class="cl"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">public class Demo2_3 {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private static final int _4MB = 4 * 1024 * 1024;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) throws IOException {
</span></span><span class="line"><span class="cl">        /*List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 5; i++) {
</span></span><span class="line"><span class="cl">            list.add(new byte[_4MB]);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.in.read();*/
</span></span><span class="line"><span class="cl">        soft();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void soft() {
</span></span><span class="line"><span class="cl">        // list --&gt; SoftReference --&gt; byte[]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 5; i++) {
</span></span><span class="line"><span class="cl">            SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB]);
</span></span><span class="line"><span class="cl">            System.out.println(ref.get());
</span></span><span class="line"><span class="cl">            list.add(ref);
</span></span><span class="line"><span class="cl">            System.out.println(list.size());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        System.out.println(&#34;循环结束：&#34; + list.size());
</span></span><span class="line"><span class="cl">        for (SoftReference&lt;byte[]&gt; ref : list) {
</span></span><span class="line"><span class="cl">            System.out.println(ref.get());
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">Connected to the target VM, address: &#39;127.0.0.1:65198&#39;, transport: &#39;socket&#39;
</span></span><span class="line"><span class="cl">[B@6f75e721
</span></span><span class="line"><span class="cl">1
</span></span><span class="line"><span class="cl">[B@69222c14
</span></span><span class="line"><span class="cl">2
</span></span><span class="line"><span class="cl">[B@606d8acf
</span></span><span class="line"><span class="cl">3
</span></span><span class="line"><span class="cl">[GC (Allocation Failure) [PSYoungGen: 1777K-&gt;464K(6144K)] 14065K-&gt;12760K(19968K), 0.0007427 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
</span></span><span class="line"><span class="cl">[B@782830e
</span></span><span class="line"><span class="cl">4
</span></span><span class="line"><span class="cl">[GC (Allocation Failure) --[PSYoungGen: 4672K-&gt;4672K(6144K)] 16968K-&gt;16968K(19968K), 0.0007738 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
</span></span><span class="line"><span class="cl">[Full GC (Ergonomics) [PSYoungGen: 4672K-&gt;4471K(6144K)] [ParOldGen: 12296K-&gt;12289K(13824K)] 16968K-&gt;16760K(19968K), [Metaspace: 2843K-&gt;2843K(1056768K)], 0.0047325 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
</span></span><span class="line"><span class="cl">[GC (Allocation Failure) --[PSYoungGen: 4471K-&gt;4471K(6144K)] 16760K-&gt;16760K(19968K), 0.0007396 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
</span></span><span class="line"><span class="cl">[Full GC (Allocation Failure) [PSYoungGen: 4471K-&gt;0K(6144K)] [ParOldGen: 12289K-&gt;361K(8192K)] 16760K-&gt;361K(14336K), [Metaspace: 2843K-&gt;2843K(1056768K)], 0.0072134 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
</span></span><span class="line"><span class="cl">[B@470e2030
</span></span><span class="line"><span class="cl">5
</span></span><span class="line"><span class="cl">循环结束：5
</span></span><span class="line"><span class="cl">null
</span></span><span class="line"><span class="cl">null
</span></span><span class="line"><span class="cl">null
</span></span><span class="line"><span class="cl">null
</span></span><span class="line"><span class="cl">[B@470e2030
</span></span><span class="line"><span class="cl">Heap
</span></span><span class="line"><span class="cl"> PSYoungGen      total 6144K, used 4378K [0x00000007bf980000, 0x00000007c0000000, 0x00000007c0000000)
</span></span><span class="line"><span class="cl">  eden space 5632K, 77% used [0x00000007bf980000,0x00000007bfdc6808,0x00000007bff00000)
</span></span><span class="line"><span class="cl">  from space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)
</span></span><span class="line"><span class="cl">  to   space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)
</span></span><span class="line"><span class="cl"> ParOldGen       total 8192K, used 361K [0x00000007bec00000, 0x00000007bf400000, 0x00000007bf980000)
</span></span><span class="line"><span class="cl">  object space 8192K, 4% used [0x00000007bec00000,0x00000007bec5a6f0,0x00000007bf400000)
</span></span><span class="line"><span class="cl"> Metaspace       used 2850K, capacity 4486K, committed 4864K, reserved 1056768K
</span></span><span class="line"><span class="cl">  class space    used 304K, capacity 386K, committed 512K, reserved 1048576K
</span></span><span class="line"><span class="cl">Disconnected from the target VM, address: &#39;127.0.0.1:65198&#39;, transport: &#39;socket&#39;
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p>
<p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong>，软引用也是占内存的，虽然不大。</p>
<p>**大概思路为：**查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">import java.lang.ref.Reference;
</span></span><span class="line"><span class="cl">import java.lang.ref.ReferenceQueue;
</span></span><span class="line"><span class="cl">import java.lang.ref.SoftReference;
</span></span><span class="line"><span class="cl">import java.util.ArrayList;
</span></span><span class="line"><span class="cl">import java.util.List;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 演示软引用, 配合引用队列
</span></span><span class="line"><span class="cl"> * 
</span></span><span class="line"><span class="cl"> * -Xmx20m
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">public class Demo2_4 {
</span></span><span class="line"><span class="cl">    private static final int _4MB = 4 * 1024 * 1024;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 引用队列
</span></span><span class="line"><span class="cl">        ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 5; i++) {
</span></span><span class="line"><span class="cl">            // 关联了引用队列， 当软引用所关联的 byte[]被回收时，自动触发，软引用自己会加入到 queue 中去
</span></span><span class="line"><span class="cl">            SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB], queue);
</span></span><span class="line"><span class="cl">            System.out.println(ref.get());
</span></span><span class="line"><span class="cl">            list.add(ref);
</span></span><span class="line"><span class="cl">            System.out.println(list.size());
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 从队列中获取无用的 软引用对象，并手动移除
</span></span><span class="line"><span class="cl">        Reference&lt;? extends byte[]&gt; poll = queue.poll();
</span></span><span class="line"><span class="cl">        while( poll != null) {
</span></span><span class="line"><span class="cl">            list.remove(poll);
</span></span><span class="line"><span class="cl">            poll = queue.poll();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;===========================&#34;);
</span></span><span class="line"><span class="cl">        for (SoftReference&lt;byte[]&gt; reference : list) {
</span></span><span class="line"><span class="cl">            System.out.println(reference.get());
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="弱引用">弱引用</h5>
<p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收<strong>弱引用对象所引用的对象</strong></p>
<ul>
<li>当GC Root指向弱引用对象，弱引用对象引用了一个对象，在触发了垃圾回收,无论内存是否充足，都会<strong>回收弱引用所引用的对象</strong></li>
<li>可以配合引用队列来释放弱引用自身</li>
<li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li>
</ul>
<p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 演示弱引用
</span></span><span class="line"><span class="cl"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">public class Demo2_5 {
</span></span><span class="line"><span class="cl">    private static final int _4MB = 4 * 1024 * 1024;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        //  list --&gt; WeakReference --&gt; byte[]
</span></span><span class="line"><span class="cl">        List&lt;WeakReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 10; i++) {
</span></span><span class="line"><span class="cl">            WeakReference&lt;byte[]&gt; ref = new WeakReference&lt;&gt;(new byte[_4MB]);
</span></span><span class="line"><span class="cl">            list.add(ref);
</span></span><span class="line"><span class="cl">            for (WeakReference&lt;byte[]&gt; w : list) {
</span></span><span class="line"><span class="cl">                System.out.print(w.get()+&#34; &#34;);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            System.out.println();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        System.out.println(&#34;循环结束：&#34; + list.size());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="虚引用cleaner-类和-reference-handler"><strong>虚引用</strong>（Cleaner 类和 reference handler）</h5>
<p><strong>虚引用和终结器引用 必须配合 引用队列使用。</strong></p>
<p>必须配合引用队列使用，主要配合 ByteBuffffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p>
<ul>
<li>
<p>创建ByteBuffer对象时，就会创建一个Cleaner虚引用对象，并把ByteBuffer对象直接内存地址传给 Cleaner虚引用对象。当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</p>
<p>虚引用作用的一个体现是<strong>释放直接内存所分配的内存</strong>，</p>
</li>
<li>
<p>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</p>
</li>
</ul>
<h5 id="终结器引用">终结器引用</h5>
<p>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize方法，第二次 GC 时才能回收被引用对象。</p>
<p><strong>只有执行了 finalize方法 ，此对象才能被垃圾回收，不然这个虽然不被引用了，但是一直没有被回收，已被废弃</strong></p>
<ul>
<li>
<p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象重写了finalize方法，不再被其他的对象所引用时，会先创建终结器引用对象并放入引用队列中。会有一个优先级很低的 finalize线程查看这个队列，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p>
</li>
<li>
<p>如上图，B对象不再引用A4对象。这时终结器对象就会被放入引用队列中，在引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法，该对象就可以被垃圾回收了</p>
</li>
</ul>
<h5 id="引用队列">引用队列</h5>
<ul>
<li>软引用和弱引用<strong>可以配合</strong>引用队列
<ul>
<li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会自动将这些引用放入引用队列中(如果代码里定义了引用队列的话），方便一起回收这些软/弱引用对象</li>
</ul>
</li>
<li>虚引用和终结器引用<strong>必须配合</strong>引用队列
<ul>
<li>虚引用和终结器引用在使用时会关联一个引用队列，不需要自定义代码实现</li>
</ul>
</li>
</ul>
<h3 id="2垃圾回收算法">2、垃圾回收算法</h3>
<h4 id="标记-清除">标记-清除</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="057_%e6%a0%87%e8%ae%b0%e6%b8%85%e9%99%a4.png"
        data-srcset="057_%e6%a0%87%e8%ae%b0%e6%b8%85%e9%99%a4.png, 057_%e6%a0%87%e8%ae%b0%e6%b8%85%e9%99%a4.png 1.5x, 057_%e6%a0%87%e8%ae%b0%e6%b8%85%e9%99%a4.png 2x"
        data-sizes="auto"
        alt="057_标记清除.png"
        title="057_标记清除.png" /></p>
<p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p>
<ul>
<li>
<p>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</p>
</li>
<li>
<p><strong>优点</strong>：速度较快</p>
</li>
<li>
<p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配（如数组，需要连续的存储空间），一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p>
</li>
</ul>
<h4 id="标记-整理">标记-整理</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="058_%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86.png"
        data-srcset="058_%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86.png, 058_%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86.png 1.5x, 058_%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86.png 2x"
        data-sizes="auto"
        alt="058_标记整理.png"
        title="058_标记整理.png" /></p>
<ul>
<li><strong>优点</strong>：速度慢</li>
<li><strong>缺点</strong>：不会有内存碎片</li>
</ul>
<p>标记-整理 会将不被GC Root引用的对象回收，清除其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，对象发生移动，对象的引用地址需要变更，所以效率较低</p>
<h4 id="复制">复制</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="059_%e5%a4%8d%e5%88%b61.jpg"
        data-srcset="059_%e5%a4%8d%e5%88%b61.jpg, 059_%e5%a4%8d%e5%88%b61.jpg 1.5x, 059_%e5%a4%8d%e5%88%b61.jpg 2x"
        data-sizes="auto"
        alt="059_复制1.jpg"
        title="059_复制1.jpg" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="059_%e5%a4%8d%e5%88%b62.jpg"
        data-srcset="059_%e5%a4%8d%e5%88%b62.jpg, 059_%e5%a4%8d%e5%88%b62.jpg 1.5x, 059_%e5%a4%8d%e5%88%b62.jpg 2x"
        data-sizes="auto"
        alt="059_复制2.jpg"
        title="059_复制2.jpg" /></p>
<ul>
<li>
<p><strong>优点</strong>：不会有内存碎片</p>
</li>
<li>
<p><strong>缺点</strong>：需要占用双倍内存空间</p>
<p>将内存分为等大小的两个区域，FROM和TO（TO一开始为空）。先将被GC Root引用的对象从FROM 拷贝到TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p>
</li>
</ul>
<h4 id="总结">总结</h4>
<p>实际这几种垃圾回收算法都会使用</p>
<h3 id="3分代回收就是指堆内存">3、分代回收(就是指堆内存)</h3>
<p>根据对象的生命周期的不同，进行不同的垃圾回收策略。</p>
<ol>
<li>对象首先分配在伊甸园区域</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="062_01.jpg"
        data-srcset="062_01.jpg, 062_01.jpg 1.5x, 062_01.jpg 2x"
        data-sizes="auto"
        alt="062_01.jpg"
        title="062_01.jpg" /></p>
<ol start="2">
<li>
<p>当新生代的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong>。Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>用复制算法</strong>放入幸存区 TO中， 并让其寿命加1，再交换两个幸存区。</p>
<p>minor gc 会引发 stop the world，暂停其它用户的线程（因为对象的地址被移动了，所以要暂停其他线程），等垃圾回收结束</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="062_02.jpg"
        data-srcset="062_02.jpg, 062_02.jpg 1.5x, 062_02.jpg 2x"
        data-sizes="auto"
        alt="062_02.jpg"
        title="062_02.jpg" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="062_03.jpg"
        data-srcset="062_03.jpg, 062_03.jpg 1.5x, 062_03.jpg 2x"
        data-sizes="auto"
        alt="062_03.jpg"
        title="062_03.jpg" /></p>
</li>
<li>
<p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>，不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="062_05.jpg"
        data-srcset="062_05.jpg, 062_05.jpg 1.5x, 062_05.jpg 2x"
        data-sizes="auto"
        alt="062_05.jpg"
        title="062_05.jpg" /></p>
</li>
<li>
<p>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="062_06.jpg"
        data-srcset="062_06.jpg, 062_06.jpg 1.5x, 062_06.jpg 2x"
        data-sizes="auto"
        alt="062_06.jpg"
        title="062_06.jpg" /></p>
</li>
<li>
<p>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gcc，STW的时间更长。如果老年代的空也不够，就触发OutOfMemory</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="062_07.jpg"
        data-srcset="062_07.jpg, 062_07.jpg 1.5x, 062_07.jpg 2x"
        data-sizes="auto"
        alt="062_07.jpg"
        title="062_07.jpg" /></p>
</li>
</ol>
<h3 id="4jvm参数">4、JVM参数</h3>
<p>堆初始大小 -Xms</p>
<p>堆最大大小 -Xmx 或 -XX:MaxHeapSize=size</p>
<p>新生代大小 -Xmn （指初始最大同时指定）或    (-XX:NewSize=size + -XX:MaxNewSize=size )</p>
<p>幸存区比例（动态） -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</p>
<p>幸存区比例（默认是8，如果新生代有10m，代表8m是伊甸园的） -XX:SurvivorRatio=ratio</p>
<p>晋升阈值(新生代晋升老年代，默认和垃圾回收器有关，如15,如6) -XX:MaxTenuringThreshold=threshold</p>
<p>晋升详情 -XX:+PrintTenuringDistribution</p>
<p>GC详情 -XX:+PrintGCDetails -verbose:gc</p>
<p>FullGC 前 MinorGC -XX:+ScavengeBeforeFullGC</p>
<p>启动一个main方法，什么都不写</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到新生代-Xmn分配了10M，但是只有9M，因为默认8(eden:1(from):1(to) ，幸存区to的1m默认是不能用的。</p>
<p>def new generation ：新生代</p>
<p>tenured generation ：老年代</p>
<p>[Full GC (Ergonomics) 就是 full gc，[GC (Allocation Failure) 就是minor gc</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Heap
</span></span><span class="line"><span class="cl"> def new generation   total 9216K, used 1896K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)
</span></span><span class="line"><span class="cl">  eden space 8192K,  23% used [0x00000007bec00000, 0x00000007bedda120, 0x00000007bf400000)
</span></span><span class="line"><span class="cl">  from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)
</span></span><span class="line"><span class="cl">  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)
</span></span><span class="line"><span class="cl"> tenured generation   total 10240K, used 0K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
</span></span><span class="line"><span class="cl">   the space 10240K,   0% used [0x00000007bf600000, 0x00000007bf600000, 0x00000007bf600200, 0x00000007c0000000)
</span></span><span class="line"><span class="cl"> Metaspace       used 3131K, capacity 4496K, committed 4864K, reserved 1056768K
</span></span><span class="line"><span class="cl">  class space    used 344K, capacity 388K, committed 512K, reserved 1048576K
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="gc-分析">GC 分析</h4>
<h5 id="大对象处理策略">大对象处理策略</h5>
<p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p>
<h5 id="线程内存溢出">线程内存溢出</h5>
<p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p>
<p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p>
<h3 id="4垃圾回收器">4、垃圾回收器</h3>
<p>几种垃圾回收器模型</p>
<h4 id="串行的-单线程的垃圾回收器">串行的 (单线程的垃圾回收器)</h4>
<p>堆内存较小，适合个人电脑</p>
<p>​    <img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="069_01_%e4%b8%b2%e8%a1%8c.jpg"
        data-srcset="069_01_%e4%b8%b2%e8%a1%8c.jpg, 069_01_%e4%b8%b2%e8%a1%8c.jpg 1.5x, 069_01_%e4%b8%b2%e8%a1%8c.jpg 2x"
        data-sizes="auto"
        alt="069_01_串行.jpg"
        title="069_01_串行.jpg" /></p>
<h4 id="吞吐量优先多线程的垃圾回收器">吞吐量优先(多线程的垃圾回收器)</h4>
<p>java -server -XX:+ScavengeBeforeFullGC -XX:+PrintGCDetails -XX:+PrintTenuringDistribution -XX:+PrintGCTimeStamps -Dspring.profiles.active=prd -Dfile.encoding=utf-8 -Djava.net.preferIPv6Addresses=false -Djava.net.preferIPv4Stack=true -Duser.timezone=Asia/Shanghai -jar -Xms2048m -Xmx2048m -Xss512m -XX:SurvivorRatio=8 -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=50 -XX:+UseParallelGC -XX:+UseParallelOldGC -XX:ParallelGCThreads=4 -XX:+UseAdaptiveSizePolicy -XX:MaxNewSize=128m -XX:NewSize=128m -Dnacos.config.server-addr=10.32.11.32:8849 -Dnacos.discovery.server-addr=10.32.11.32:8849 ${project.build.finalName}.jar</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">java -server -XX:+ScavengeBeforeFullGC -
</span></span><span class="line"><span class="cl">XX:+PrintGCDetails 
</span></span><span class="line"><span class="cl">-XX:+PrintTenuringDistribution 
</span></span><span class="line"><span class="cl">-XX:+PrintGCTimeStamps
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-Dspring.profiles.active=prd 
</span></span><span class="line"><span class="cl">-Dfile.encoding=utf-8 
</span></span><span class="line"><span class="cl">-Djava.net.preferIPv6Addresses=false 
</span></span><span class="line"><span class="cl">-Djava.net.preferIPv4Stack=true 
</span></span><span class="line"><span class="cl">-Duser.timezone=Asia/Shanghai -jar 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-Xms2048m -Xmx2048m 
</span></span><span class="line"><span class="cl">-Xss512m 
</span></span><span class="line"><span class="cl">-XX:SurvivorRatio=8 
</span></span><span class="line"><span class="cl">-XX:+UseCMSInitiatingOccupancyOnly 
</span></span><span class="line"><span class="cl">-XX:CMSInitiatingOccupancyFraction=50 
</span></span><span class="line"><span class="cl">-XX:+UseParallelGC -XX:+UseParallelOldGC 
</span></span><span class="line"><span class="cl">-XX:ParallelGCThreads=4 
</span></span><span class="line"><span class="cl">-XX:+UseAdaptiveSizePolicy 
</span></span><span class="line"><span class="cl">-XX:MaxNewSize=128m 
</span></span><span class="line"><span class="cl">-XX:NewSize=128m
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> -Dnacos.config.server-addr=10.32.11.32:8849
</span></span><span class="line"><span class="cl"> -Dnacos.discovery.server-addr=10.32.11.32:8849
</span></span><span class="line"><span class="cl"> ${project.build.finalName}.jar
</span></span></code></pre></td></tr></table>
</div>
</div><p>让<strong>单位时间</strong>内，STW 的时间最短 0.2 0.2 = 0.4，垃圾回收时间占程序运行时间比最低，这样就称吞吐量高</p>
<p>堆内存较大，多核cpu</p>
<p>但用户线程不能运行了</p>
<p>​    <img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="069_02_%e5%90%9e%e5%90%90%e9%87%8f.jpg"
        data-srcset="069_02_%e5%90%9e%e5%90%90%e9%87%8f.jpg, 069_02_%e5%90%9e%e5%90%90%e9%87%8f.jpg 1.5x, 069_02_%e5%90%9e%e5%90%90%e9%87%8f.jpg 2x"
        data-sizes="auto"
        alt="069_02_吞吐量.jpg"
        title="069_02_吞吐量.jpg" /></p>
<p>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC</p>
<p>-XX:+UseAdaptiveSizePolicy    此参数代表 打开动态调整伊甸园与幸存区的比例的开关</p>
<p>-XX:GCTimeRatio=ratio          默认值99，吞吐量  1/(1+99）（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%，增大堆的大小，可以减少gc数量，增加吞吐量。</p>
<p>-XX:MaxGCPauseMillis=ms    最大暂停毫秒数 即 每次gc花费的时间。堆越大，花费时间越长。</p>
<p>-XX:ParallelGCThreads=n</p>
<h4 id="响应时间优先多线程的垃圾回收器如cms">响应时间优先(多线程的垃圾回收器，如CMS)</h4>
<p>堆内存较大，多核 cpu</p>
<p>尽可能让<strong>单次</strong> STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5s</p>
<p>​    <img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="071_cms.png"
        data-srcset="071_cms.png, 071_cms.png 1.5x, 071_cms.png 2x"
        data-sizes="auto"
        alt="071_cms.png"
        title="071_cms.png" /></p>
<p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p>
<p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上，可以减少 STW。</p>
<h5 id="cms-收集器">CMS 收集器</h5>
<p>Concurrent Mark Sweep，一种以<strong>响应时间短</strong>老年代垃圾收集器</p>
<p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片，CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的。</p>
<p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p>
<p><strong>CMS收集器的运行过程分为下列4步：</strong></p>
<p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p>
<p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行,剩余的垃圾找出来？</p>
<p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p>
<p><strong>并发清除</strong>：对标记的对象进行清除回收</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld 
</span></span></code></pre></td></tr></table>
</div>
</div><p>ConcMarkSweepGC CMS 是工作在老年代的垃圾回收器，与之配合的UseParNewGC 是工作在新生代。CMS有可能会因为内存碎片化的问题退化到SerialOld 单线程（串行的垃圾回收器使用的），垃圾回收时间会非常慢。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads       
</span></span></code></pre></td></tr></table>
</div>
</div><p>-XX:ParallelGCThreads=4 ~ -XX:ConcGCThreads=1  代表1个线程gc，3个线程给用户，按照这样的比例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-XX:CMSInitiatingOccupancyFraction=percent 
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个参数就是何时触发垃圾回收。不能堆内存占100%的时候去GC，因为并发清理时候也会产生浮动垃圾，这些浮动垃圾没地方存。这样说懂了吧。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-XX:+CMSScavengeBeforeRemark
</span></span></code></pre></td></tr></table>
</div>
</div><p>在重新标记的阶段，有可能新生代的对象引用了老年代的对象。如果重新标记要扫描整个堆，新生代的个数比较多，而且本身就有可能已经是垃圾了。就算从新生代找到老年代，就算老年代被引用了，但实际上最终还是要被回收掉。</p>
<p>XX:+CMSScavengeBeforeRemark，在重新标记之前，先执行一次ygc，回收掉年轻带的对象无用的对象，并将对象放入幸存带或晋升到老年代，这样再进行年轻带扫描时，只需要扫描幸存区的对象即可，一般幸存带非常小，这大大减少了扫描时间。</p>
<p><a href="https://juejin.cn/post/6844903782107578382" target="_blank" rel="noopener noreffer">https://juejin.cn/post/6844903782107578382</a>
</p>
<h4 id="g1">G1</h4>
<h5 id="定义-5"><strong>定义</strong>：</h5>
<p>Garbage First</p>
<p>JDK 9以后默认使用，而且替代了CMS 收集器</p>
<h5 id="适用场景">适用场景</h5>
<ul>
<li>同时注重吞吐量和低延迟（响应时间）</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li>
<li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li>
</ul>
<p>相关 JVM 参数</p>
<p>-XX:+UseG1GC</p>
<p>-XX:G1HeapRegionSize=size</p>
<p>-XX:MaxGCPauseMillis=time</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="073_g1.png"
        data-srcset="073_g1.png, 073_g1.png 1.5x, 073_g1.png 2x"
        data-sizes="auto"
        alt="073_g1.png"
        title="073_g1.png" /></p>
<p>E：伊甸园 S：幸存区 O：老年代</p>
<h5 id="1young-collection">1.Young Collection</h5>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="073_g1_01.png"
        data-srcset="073_g1_01.png, 073_g1_01.png 1.5x, 073_g1_01.png 2x"
        data-sizes="auto"
        alt="073_g1_01.png"
        title="073_g1_01.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="073_g1_02.png"
        data-srcset="073_g1_02.png, 073_g1_02.png 1.5x, 073_g1_02.png 2x"
        data-sizes="auto"
        alt="073_g1_02.png"
        title="073_g1_02.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="073_g1_03.png"
        data-srcset="073_g1_03.png, 073_g1_03.png 1.5x, 073_g1_03.png 2x"
        data-sizes="auto"
        alt="073_g1_03.png"
        title="073_g1_03.png" /></p>
<h5 id="2young-collection--cm">2.Young Collection + CM</h5>
<p>CM：并发标记</p>
<ul>
<li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li>
<li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="076_g1_01.png"
        data-srcset="076_g1_01.png, 076_g1_01.png 1.5x, 076_g1_01.png 2x"
        data-sizes="auto"
        alt="076_g1_01.png"
        title="076_g1_01.png" /></p>
<p><a href="https://juejin.cn/post/7010034105165299725" target="_blank" rel="noopener noreffer">https://juejin.cn/post/7010034105165299725</a>
</p>
<h3 id="5直接内存">5、直接内存</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="directbuff-io.png"
        data-srcset="directbuff-io.png, directbuff-io.png 1.5x, directbuff-io.png 2x"
        data-sizes="auto"
        alt="directbuff-io.png"
        title="directbuff-io.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="directbuff-nio.png"
        data-srcset="directbuff-nio.png, directbuff-nio.png 1.5x, directbuff-nio.png 2x"
        data-sizes="auto"
        alt="directbuff-nio.png"
        title="directbuff-nio.png" /></p>
<p>并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存</p>
<p>常见于NIO操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受JVM内存回收管理</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2022-10-11</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://shengtu0328.github.io/posts/jvm/" data-title="JVM学习"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://shengtu0328.github.io/posts/jvm/"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="https://shengtu0328.github.io/posts/jvm/" data-title="JVM学习"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://shengtu0328.github.io/posts/jvm/" data-title="JVM学习"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@6.20.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://shengtu0328.github.io/posts/jvm/" data-title="JVM学习"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/ffmpeg/" class="prev" rel="prev" title="FFmpeg"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>FFmpeg</a>
            <a href="/posts/spring/" class="next" rel="next" title="Spring">Spring<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.105.0">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2019 - 2024</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">ricky</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"search":{"highlightTag":"em","maxResultLength":10,"noResultsFound":"No results found","snippetLength":50}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
